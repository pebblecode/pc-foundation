##|TYPE Template
##|UNIQUEID 154e767f-a5c7-4506-b454-1c6bbbedac02
##|TITLE BusinessEntity
##|NAMESPACE IBatis.DataLayer
##|SOURCE_TYPE Source
##|OUTPUT_LANGUAGE None
##|GUI_ENGINE .Net Script
##|GUI_LANGUAGE C#
##|GUI_BEGIN

public class GeneratedGui : DotNetScriptGui
{
	public GeneratedGui(ZeusContext context) : base(context) {}

	//-----------------------------------------
	// The User Interface Entry Point
	//-----------------------------------------
	public override void Setup()
	{
		// ** UNCOMMENT CODE BELOW TO SEE UI **

		//ui.Width  = 100;
		//ui.Height = 100;
		//GuiLabel lblDemo = ui.AddLabel("lblDemo", "Demo", "Demo Tooltip");
		//ui.ShowGui = true;
	}

}
##|GUI_END
##|BODY_MODE Markup
##|BODY_ENGINE .Net Script
##|BODY_LANGUAGE C#
##|BODY_TAG_START <%
##|BODY_TAG_END %>
##|BODY_BEGIN
<%#NAMESPACE System.IO, System.Text, System.Text.RegularExpressions, System.Globalization, System.Collections.Generic%><%
public class GeneratedTemplate : DotNetScriptTemplate
{
	%><%#FILE CSharp_IBatis_DataLayer_Common.cs%><% 
	
	// Constructor
	public GeneratedTemplate(ZeusContext context) : base(context) {}

	//---------------------------------------------------
	// Render() is where you want to write your logic    
	//---------------------------------------------------
	public override void Render( )
	{
		// Call a method defined in IBatis_Boardbooks_Common.cs
		AssignMemberVariables();

		// Class name??
		string classPrefix = 
			_isControlledUpdate && _isVersioned ? "ConcreteControlledUpdate" : 
			(_isVersioned ? "Versioned" : "");

		// Comment back in to dump foreign key names to top of file
		// Use for debugging purposes only
		//DumpKeys();
		
		// Now output the template

%>/*****************************************************************************/
/***                                                                       ***/
/***    This is an automatically generated file. It is generated using     ***/
/***    MyGeneration in conjunction with IBatisBusinessObject template.    ***/
/***                                                                       ***/
/***    DO NOT MODIFY THIS FILE DIRECTLY!                                  ***/
/***                                                                       ***/
/***    If you need to make changes either modify the template and         ***/
/***    regenerate or derive a class from this class and override.         ***/
/***                                                                       ***/
/*****************************************************************************/

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using System.Linq;
using Microsoft.FSharp.Collections;

using PebbleCode.Framework.Collections;
using PebbleCode.Framework.Dates;
using PebbleCode.Framework.Utilities;
using PebbleCode.Entities;
using PebbleCode.ExpressionTree;

namespace <%= _entityNamespace %>
{
	/// <summary>
	///	Generated by MyGeneration using the IBatis Object Mapping template
	/// </summary>
	[Serializable]
	public partial class <%= _className %> : <%= classPrefix %>Entity
	{
        /// <summary>
        /// Get the entity type
        /// </summary>
		public override Flags EntityFlag { get { return EntityType.<%= _className %>; } }
		
		<% BuildPrivateMembers( _columns ); %>
		
		<% BuildDefaultConstructor( _columns ); %>
		
		<% BuildForeignKeyRepresentation( ); %>
		
		<% BuildPublicAccessors( _columns ); %>
		
		<% BuildDbAccessors( _columns ); %>
		
		<% BuildNodeBuilders( _columns ); %>
		
		<% BuildCloneMethod( _columns ); %>		
		
		<% BuildTestAccessors( _columns ); %>		
		
		<% if (_pk != null)
		{
		%>/// <summary>
		/// Overriden method to get the Id of the entity
		/// </summary>
		public override <%= ColumnToMemberType( _pk ) %> Identity
		{
			get { return <%= ColumnToMemberVariable( _pk ) %>; }
		}<%
		}  // End of if (_pk != null)
		
		if ( _addReadOnlyAccessors )
		{
		%>/// <summary>
        /// Get the base business entity as read only wrapper
        /// </summary>
        /// <returns>The readonly only entity wrapper</returns>
        public override ReadOnlyBusinessEntity<T> AsReadOnlyEntity<T>()
		{
			return this.AsReadOnly() as ReadOnlyBusinessEntity<T>;
		}

		/// <summary>
		///	Returns a readonly version of the instance of <%= _className %>
		/// </summary>
		public ReadOnly<%= _className %> AsReadOnly()
        {
			return new ReadOnly<%= _className %>( this );
		}<%
		} // end of if ( _addReadOnlyAccessors )
		%>
	}

    /// <summary>
    /// Event args class for <%= _className %>
    /// </summary>
    public class <%= _className %>EventArgs : EventArgs
    {
        public <%= _className %> <%= ToPropertyName(_className) %> { get; private set; }

        public <%= _className %>EventArgs(<%= _className %> <%= ToVariableName(_className) %>)
        {
            <%= ToPropertyName(_className) %> = <%= ToVariableName(_className) %>;
        }
    }
}<%
	}
		
	private void BuildPrivateMembers( IColumns Columns )
	{
		if( Columns.Count > 0 )
		{
			%>#region Private Members<%
		
			foreach( IColumn field in Columns )
			{
				if (IsExcluded(field)) continue;
				if (IsVersionedOrControlledUpdateField(field)) continue;
				
				string initialValue = InitialValue(field);
				
				// Output all others
				%>
		[DataMember]
		private <%= ColumnToMemberType( field ) %> <%= ColumnToMemberVariable( field ) %><% if (initialValue != null) {%> = <%= initialValue %><%}%>;<%
			
				// Additional member for encrypted values
			    if ( IsEncrypted(field) )
				{%>
		private <%= ColumnToMemberType( field ) %> <%= ColumnToEncryptedMemberVariable( field ) %>;<%
				}
			}
%>
		#endregion<%
		}
	}
	
	private void BuildTestAccessors( IColumns Columns )
	{%>#region Test Utilities
		
		/// <summary>
		/// Used for testing - allows stub objects to be created simply.  Ensure that
		/// the test assembly's name is added to AssemblyInfo (in your projects entities 
		/// dll - e.g. CT.Entities) inside an InternalsVisisbleToAttribute
		/// </summary>
		/// <param name="id">ID to use for test stub</param>
		internal virtual void SetId(int id)
		{
			_id = id;
			_isNew = false;
		}
		
		#endregion<%
	}
	
	private void BuildForeignKeyRepresentation( )
	{
		BuildForeignKeyEntities();
		BuildForeignKeyCollections();
	}
	
	private void BuildForeignKeyEntities()
	{
		IList<IForeignKey> foreignKeys = GetNonPrimaryForeignKeys();
		if (foreignKeys.Count < 1)
			return;
			
		%>#region Foreign Key Entities<%
		
		foreach(IForeignKey foreignKey in foreignKeys)
		{
			KeyDetails pkInfo = GetPrimaryKeyDetails(foreignKey);

			// Output foreign key entity			%>
				
        /// <summary>
        /// Get the associated <%= pkInfo.PropertyName %>
        /// </summary>
        public <%= pkInfo.ClassName %> <%= pkInfo.PropertyName %>
        {
            get 
            {
                if (!<%= pkInfo.MemberName %>Populated)
                    throw new InvalidOperationException("<%= pkInfo.MemberName %> not populated yet");
                return <%= pkInfo.MemberName %>;
            }
			set
			{
				<%= pkInfo.MemberName %> = value;
				<%= pkInfo.MemberName %>Populated = true;<% 
				if (pkInfo.ForeignKeyIsNullable) { %>
				<%= ToPropertyName(pkInfo.ColumnName) %> = value != null ? value.Identity : (<%= pkInfo.KeyPropertyType %>)null;<%
				} else { %>
				<%= ToPropertyName(pkInfo.ColumnName) %> = value.Identity;<% 
				} %>
			}
        }
		
		[DataMember]
		private <%= pkInfo.ClassName %> <%= pkInfo.MemberName %> = null;
		[DataMember]
		private bool <%= pkInfo.MemberName %>Populated = false;
		
        /// <summary>
        /// Is <%= pkInfo.PropertyName %> getable yet?
        /// </summary>
        public bool <%= pkInfo.PropertyName %>Populated
        {
            get { return <%= pkInfo.MemberName %>Populated; }
        }
		
        /// <summary>
        /// Does <%= pkInfo.PropertyName %> require population?
        /// </summary>
        public bool <%= pkInfo.PropertyName %>RequiresPopulation
        {
            get 
			{
				<% if (pkInfo.ForeignKeyIsNullable) 
				{ 
				%>return <%= pkInfo.MemberName %>Populated == false && <%= pkInfo.KeyPropertyName %>.HasValue;<%
				} 
				else 
				{ 
				%>return <%= pkInfo.MemberName %>Populated == false; <% 
				} %>
			}
        }
		
        /// <summary>
        /// Clear <%= pkInfo.PropertyName %> and mark as not populated anymore
        /// </summary>
        public void Unpopulate<%= pkInfo.PropertyName %>()
        {
			<%= pkInfo.MemberName %>Populated = false;
			<%= pkInfo.MemberName %> = null;
        }<%
		}
%>
		#endregion<%
	}
	
	private void BuildForeignKeyCollections()
	{
		IList<IForeignKey> foreignKeys = GetPrimaryForeignKeys();
		if (foreignKeys.Count < 1)
			return;
			
		%>
		#region Foreign Key Collections<%
		
		foreach(IForeignKey foreignKey in foreignKeys)
		{
			KeyDetails fkInfo = GetForeignKeyDetails(foreignKey);

			// Output foreign key setup
			%>
				
        /// <summary>
        /// Get the associated <%= fkInfo.PropertyName %>
        /// </summary>
        public <%= fkInfo.ListClassName %> <%= fkInfo.PropertyName %>
        {
            get 
            {
                if (<%= fkInfo.MemberName %> == null)
					if (IsNew)
						<%= fkInfo.MemberName %> = new <%= fkInfo.ListClassName %>();
					else
						throw new InvalidOperationException("<%= fkInfo.MemberName %> not populated yet");
                return <%= fkInfo.MemberName %>;
            }
        }
		
		[DataMember]
		private <%= fkInfo.ListClassName %> <%= fkInfo.MemberName %> = null;
		
        /// <summary>
        /// Is <%= fkInfo.PropertyName %> getable yet?
        /// </summary>
        public bool <%= fkInfo.PropertyName %>Populated
        {
            get { return <%= fkInfo.MemberName %> != null; }
        }

        /// <summary>
        /// Populate <%= fkInfo.PropertyName %>
        /// </summary>
        /// <param name="<%= ToVariableName(fkInfo.ListClassName) %>"></param>
        public void Populate<%= fkInfo.PropertyName %>(IEnumerable<<%= fkInfo.ClassName %>> <%= ToVariableName(fkInfo.ListClassName) %>)
        {
			if (<%= ToVariableName(fkInfo.ListClassName) %> == null)
				<%= fkInfo.MemberName %> = new <%= fkInfo.ListClassName %>();
			else
				<%= fkInfo.MemberName %> = new <%= fkInfo.ListClassName %>(<%= ToVariableName(fkInfo.ListClassName) %>);
        }
		
        /// <summary>
        /// Clear all items from <%= fkInfo.PropertyName %> and mark as not populated anymore
        /// </summary>
        public void Unpopulate<%= fkInfo.PropertyName %>()
        {
            <%= fkInfo.MemberName %> = null;
        }<%
		}
%>
		#endregion<%
	}
	
	private void BuildDefaultConstructor( IColumns Columns )
	{
		
		%>/// <summary>
        /// Constructor
		/// </summary>
		public <%= _className %>()
		{
			// Initialise database field values<%
		foreach( IColumn field in Columns )
		{
			if (IsExcluded(field)) continue;
			if (IsVersionedOrControlledUpdateField(field)) continue;
			
			string fieldName = ColumnToMemberVariable( field );
			string fieldType = ColumnToMemberType( field );
			
			switch( fieldType )
			{
				case "ForeignEntityKey<int>":
				case "PrimaryEntityKey<int>":%>
			<%= fieldName %> = new <%= fieldType %>(0, 0, this); <%
					break;
				case "ForeignEntityKey<int?>":
				case "PrimaryEntityKey<int?>":%>
			<%= fieldName %> = new <%= fieldType %>(null, null, this); <%
					break;
				// Do nothing for types that get the default we want
				// That will be: 0 for numbers; false for bool; null for classes
				default:
					break;
			}
		}%>
			OnCreated();
		}<%
	}

	private void BuildPublicAccessors( IColumns Columns )
	{
		if( Columns.Count > 0 )
		{
			%>#region Public Properties
			<%
	
			foreach( IColumn field in Columns )
			{
				if (IsExcluded(field)) continue;
				if (IsVersionedOrControlledUpdateField(field)) continue;
				
				string fieldAccessor = ColumnToPropertyName( field );
				string fieldName = ColumnToMemberVariable( field );
				string encryptedFieldAccessor = ColumnToEncryptedPropertyName( field );
				string encryptedFieldName = ColumnToEncryptedMemberVariable( field );
				string fieldType = ColumnToMemberType( field );				
			%>
		/// <summary>
		/// Public accessor for <%= fieldName %>
		/// </summary>		
		public virtual <%= fieldType %> <%= fieldAccessor %>
		{
			get { return <%= fieldName %>; }<% 
				if( field != _pk && !_doingSummary) // && _workingSource.IsTable
				{
					%>
			set
			{<% if(fieldType == "string") 
			    {%>
				if (value != null) 
				{
					value = value.Trim();
				}
			  <%}%>
				if (<%= fieldName %> != value && PropertyValueChanging("<%= fieldAccessor %>", value))
				{
					<%= fieldName %> = value;
					PropertyValueChanged("<%= fieldAccessor %>");<%
					if( IsEncrypted(field) )
					{
						%>
					<%= encryptedFieldName %> = null;<% 
					}
					%>
				}
			}<%						
				}%>
		}
		<%
				if (IsEncrypted(field))
				{
			%>
		/// <summary>
		/// Public accessor to set encrypted <%= fieldName %> before save
		/// </summary>		
        /// <param name="value">The encrypted value for <%= fieldName %></param>
		public void Set<%= encryptedFieldAccessor %>(<%= fieldType %> value)
		{
			<%= encryptedFieldName %> = value;
		}
			<%
				} // End of if encrypted
			} // End of foreach
			%>
		#endregion<%
		}
	}

	private void BuildDbAccessors( IColumns Columns )
	{
		if( Columns.Count > 0 )
		{
			%>#region Database Properties
			<%
	
			foreach( IColumn field in Columns )
			{
				if (IsExcluded(field)) continue;
				if (IsVersionedOrControlledUpdateField(field)) continue;
				string fieldAccessor = ColumnToDbPropertyName( field );
				string encryptedFieldName = ColumnToEncryptedMemberVariable( field );
				string fieldName = ColumnToMemberVariable( field );
				string fieldType = ColumnToDbPropertyType( field );
				
			%>
		/// <summary>
		/// Database accessor for <%= fieldName %>. Only used by IBatis.
		/// </summary>
		[SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		internal <%= fieldType %> <%= fieldAccessor %>
		{<%
				
				// Write the getter
				
				if (IsEncrypted(field))
				{
		%>
			get 
			{
				if ( <%= encryptedFieldName %> != null )
					return <%= encryptedFieldName %>;
				else
					return <%= fieldName %>;
			}<%
				}
				else if (IsIntDate(field))
				{
		%>
			get { return DbConvert.ToDateInt(<%= fieldName %>);  }<%
				}
				else if (IsFlags(field) && fieldType == "string")
				{
		%>
			get { return <%= FlagsType(field)%>.ToName(<%= fieldName %>);  }<%
				}
				else if (IsFlags(field) && fieldType == "int")
				{
		%>
			get { return <%= fieldName %>.Values[0];  }<%
				}
				else if (IsEnum(field) && fieldType == "string")
				{
		%>
			get { return <%= fieldName %>.ToString();  }<%
				}
				else if (IsEnum(field))
				{
		%>
			get { return (<%=fieldType%>)<%= fieldName %>;  }<%
				}
				else if (IsSerialised(field) && fieldType == "string")
				{
		%>
			get { return SerialisationUtils.ToXml<<%= SerialisedType(field) %>>(<%= fieldName %>);  }<%
				}
				else if (IsSerialised(field) && fieldType == "byte[]")
				{
		%>
			get { return SerialisationUtils.ToBinary<<%= SerialisedType(field) %>>(<%= fieldName %>);  }<%
				}
				else if (IsSerialised(field))
				{
		%>
			get { /* ERROR: DB field must be a string */ }<%
				}
				else
				{
		%>
			get { return <%= fieldName %>;  }<%
				}
				
				
				// Write the setter

				if (IsEnum(field) && fieldType == "string")
				{
		%>
			set { <%= fieldName %> = (<%=EnumType(field)%>)Enum.Parse(typeof(<%=EnumType(field)%>), value); }<%
				}
				else if (IsEnum(field))
				{
		%>
			set { <%= fieldName %> = (<%= ColumnToMemberType( field ) %>)value; }<%
				}
				else if (IsIntDate(field))
				{
		%>
			set { <%= fieldName %> = DbConvert.FromDateInt(value); }<%
				}
				else if (IsFlags(field) && fieldType == "string")
				{
		%>
			set { <%= fieldName %> = <%= FlagsType(field)%>.FromName(value); }<%
				}
				else if (IsFlags(field) && fieldType == "int")
				{
		%>
			set { <%= fieldName %> = new Flags(value); }<%
				}
				else if (IsSerialised(field) && fieldType == "string")
				{
		%>
			set { <%= fieldName %> = SerialisationUtils.FromXml<<%= SerialisedType(field) %>>(value); }<%
				}
				else if (IsSerialised(field) && fieldType == "byte[]")
				{
		%>
			set { <%= fieldName %> = SerialisationUtils.FromBinary<<%= SerialisedType(field) %>>(value); }<%
				}
				else if (IsSerialised(field))
				{
		%>
			set { /* ERROR: DB field must be a string */ }<%
				}
				else
				{
		%>
			set { <%= fieldName %> = value; }<% 
				}
				%>
		}
<%			}
			%>
		#endregion<%
		}
	}
	
	private void BuildNodeBuilders( IColumns Columns )
	{
		// Look for the columns marked as NodeId columns
		List<string> parametersToStrings = new List<string>();
		StringBuilder builderParamsDef = new StringBuilder();
		StringBuilder builderParams = new StringBuilder();
		StringBuilder builderPropertyParams = new StringBuilder();
		StringBuilder builderPropertyNullParams = new StringBuilder();
		StringBuilder builderMembers = new StringBuilder();
		Dictionary<string, string> commonAttribs = new Dictionary<string, string>();		
		bool isFirst = true;
		bool hasCreatedNodeBuilder = false;
		foreach( IColumn field in Columns )
		{
			string columnType = ColumnToMemberType( field );
			if(field.Properties.ContainsKey("IsNodeId")){
				string paramName = ToVariable(field);
				builderParamsDef.AppendFormat("{0}{1}{2} {3}", 
						(isFirst ? "" : ", "), 
						columnType, 
						((IsValueType(field) && !field.IsNullable) ? "?" : ""), 
						paramName);
				builderParams.AppendFormat("{0}{1}", (isFirst ? "" : ", "), paramName);
				builderPropertyParams.AppendFormat("{0}{1}", 
						(isFirst ? "" : ", "), 
						ToVariableName(_className) + "." + ColumnToPropertyName(field));
				builderPropertyNullParams.AppendFormat("{0}{1}{2}", 
						(isFirst ? "" : ", "), 
						paramName,
						": null");
				builderMembers.AppendFormat("{0}{1}", (isFirst ? "" : ", "), ColumnToMemberVariable(field));
				
				
				if (IsIntDate(field))
					parametersToStrings.Add("DateUtils.ToYYYYMMDD(" + paramName + "), ");
				else if(columnType == "string")
					parametersToStrings.Add(string.Format("{0} ?? string.Empty, ", paramName));
				else if (IsValueType(field) && !field.IsNullable)
					parametersToStrings.Add(string.Format("{0}.ToString(), ", paramName));
				else
					parametersToStrings.Add(string.Format("{0} == null ? string.Empty : {0}.ToString(), ", paramName));
					
				isFirst = false;
			}
			if(field.Properties.ContainsKey("NodeAttribute")){
				switch(columnType){
					case "DateTime?":
					case "DateTime":
						commonAttribs.Add(field.Properties["NodeAttribute"].Value, ColumnToMemberVariable(field) + ".ToShortDateString()");
						break;
					case "string":
						commonAttribs.Add(field.Properties["NodeAttribute"].Value, ColumnToMemberVariable(field));
						break;
					default:
						commonAttribs.Add(field.Properties["NodeAttribute"].Value, ColumnToMemberVariable(field) + ".ToString()");
						break;
				}
			}
			
			if (field.Properties.ContainsKey("NodeBuilder")) hasCreatedNodeBuilder = true;
		}
		if(hasCreatedNodeBuilder)
		{
			parametersToStrings[parametersToStrings.Count-1] = 
				parametersToStrings[parametersToStrings.Count-1].TrimEnd(' ', ',');
		}
		
		if(hasCreatedNodeBuilder){
		%>#region Node Builder
		
<%
		
			//Render NodeBuilder functions for each column
			foreach( IColumn field in Columns )
			{
				if (IsExcluded(field)) continue;
				if (IsVersionedOrControlledUpdateField(field)) continue;
				if (!field.Properties.ContainsKey("NodeBuilder")) continue;
				string fieldPropertyName = ColumnToPropertyName(field);
%>
		/// <summary>
        /// Building <%=fieldPropertyName %> Node
        /// </summary>
		/// <param name="displayName">Optional, defaults to field's property name when empty or null</param>
        /// <returns>Value Node for <%= fieldPropertyName %> </returns>
        public Node BuildNode_<%=fieldPropertyName %>(string displayName = null)
        {
            NodeMeta meta = new NodeMeta(BuildNodeId_<%=fieldPropertyName %>());
            SetCommonAttributes(meta);
			if (string.IsNullOrWhiteSpace(displayName))
			{
				displayName = 
					GetNodeIdCodes(<%=builderMembers.ToString()%>)
					.Aggregate("<%=fieldPropertyName %>", (current, code) => current + " " + code);
			}
			meta.Name = displayName;
            return Node.NewValue(meta, ValueSource.Entity, <%=ColumnToMemberType( field ) == "decimal" ? ColumnToMemberVariable(field) : "Convert.ToDecimal(" + ColumnToMemberVariable(field) + ")" %>);
        }
			
		/// <summary>
		///	Build NodeId to uniquely identify <%= fieldPropertyName %> by <%= _className %>
		/// </summary>
		public static NodeId BuildNodeId_<%=fieldPropertyName %>(<%= _className %> <%=ToVariableName(_className) %>)
        {
            return <%=ToVariableName(_className) %> != null ?
                BuildNodeId_<%=fieldPropertyName %>(<%=builderPropertyParams.ToString() %>)
                : BuildNodeId_<%=fieldPropertyName %>(<%=builderPropertyNullParams.ToString() %>);
        }
		
		/// <summary>
		///	Build NodeId to uniquely identify <%= fieldPropertyName %>
		/// </summary>
		public static NodeId BuildNodeId_<%=fieldPropertyName %>(<%=builderParamsDef.ToString() %>)
        {
            return BuildNodeId("<%=_className %>_<%=fieldPropertyName %>", <%=builderParams.ToString() %>);
        }
		
		/// <summary>
		///	Build NodeId to uniquely identify <%= fieldPropertyName %>
		/// </summary>
		public NodeId BuildNodeId_<%=fieldPropertyName %>()
        {
            return BuildNodeId("<%=_className %>_<%=fieldPropertyName %>", <%=builderMembers.ToString()%>);
        }
<% 			}%>
		/// <summary>
		/// Building uniuqe NodeId
		/// </summary>
		private static NodeId BuildNodeId(string nodeName, <%=builderParamsDef.ToString() %>)
        {
            return new NodeId(nodeName, ListModule.OfSeq(GetNodeIdCodes(<%=builderParams.ToString() %>)));
		}
		
		/// <summary>
		/// Get uniuqe NodeId codes
		/// </summary>
		private static IEnumerable<string> GetNodeIdCodes(<%=builderParamsDef.ToString() %>)
        {
            var codes =
		        new List<string>
		            {
<% foreach( string field in parametersToStrings ){ 
%>						<%=field%>
<%}%>					};
			return codes.Where(code => !string.IsNullOrEmpty(code));
		}

		/// <summary>
        /// Setting up common attributes to node
        /// </summary>
        /// <param name="container"></param>
		private void SetCommonAttributes(IAttributeContainer container)
        {
			SetCustomAttributes(container);
<% 			
			foreach(string attribKey in commonAttribs.Keys)
			{
%>			container.setAttr("<%= attribKey %>", <%=commonAttribs[attribKey] %>);			
<% 			} 
%>		}

		#endregion<%
		
		}
	}

	private void BuildCloneMethod( IColumns Columns )
	{
		%>#region IClonable Members
		
		/// <summary>
		///	Returns a copy of the instance of <%= _className %>
		/// </summary>
		/// <remarks>
		/// Overrides the base version, but calls OnClone to allow base classes chance
		/// to clone their information
		/// </remarks>
		public override object Clone()
        {
			// All of the value types are cloned using memberwise clone
			<%= _className %> clone = (<%= _className %>)this.MemberwiseClone();

			// Copy any other instances which are not known about by myGen
			OnClone(clone);
<% 			

		// Deal reference types (i.e. objects)
		List<IColumn> referenceFields = new List<IColumn>();
		foreach( IColumn field in Columns )
		{
			if (IsExcluded(field)) continue;
			if (IsVersionedOrControlledUpdateField(field)) continue;
			
			switch( ColumnToMemberType( field ) )
			{
				//make sure it's not a value type
				case "DateTime?":
				case "decimal?":
				case "float?":
				case "short?":
				case "int?":
				case "long?":
				case "bool?":
				case "double?":
				case "bool":
				case "decimal":
				case "float":
				case "short":
				case "int":
				case "long":
				case "ushort":
				case "uint":
				case "ulong":
				case "ushort?":
				case "uint?":
				case "ulong?":
				case "string":
				case "byte[]":
				case "DateTime":
				case "double":
				case "Guid":
					break;

				//we need to do something about the collections...???
				
				default:
					// if its an enum then do nothing
					if (!IsEnum(field))
						referenceFields.Add(field);
					break;
			}
		}
		
		// Do any fields need a clone?
		if (referenceFields.Count > 0)
		{%>			
			// Copy reference objects
<% 			
			foreach (IColumn field in referenceFields)
			{
				string fieldName = ColumnToMemberVariable( field );
				string fieldType = ColumnToMemberType( field );
%>			clone.<%= fieldName %> = (<%= fieldType %>)this.<%= fieldName %>.Clone();
<% 			}
		}%>		
			// Return our pristine clone!
            return clone;
		}
		
		#endregion<%
	}

	private void WriteFieldDefinitionConstructor(IColumn field)
	{
		string fieldType = ColumnToMemberType(field);
		string propertyName = ColumnToPropertyName( field );
		string displayName = ColumnToDisplayName(field);
		string isRequired = !field.IsNullable ? "true" : "false";
		
		switch(fieldType)
		{
			case "string": 
				WriteStringFieldDefinitionConstructor(field, propertyName, displayName, isRequired); 
				break;
				
			case "DateTime": 
				WriteDateTimeFieldDefinitionConstructor(field, propertyName, displayName, isRequired); 
				break;
				
			case "byte[]":
				WriteDataFieldDefinitionConstructor(field, propertyName, displayName, isRequired); 
				break;

			case "decimal?":
			case "float?":
			case "short?":
			case "int?":
			case "long?":
			case "double?":
			case "decimal":
			case "float":
			case "short":
			case "int":
			case "long":
			case "double":
				WriteNumericFieldDefinitionConstructor(field, propertyName, displayName, isRequired); 
				break;
				
			default: 
				WriteDefaultFieldDefinitionConstructor(field, propertyName, displayName, isRequired); 
				break;
		}
	}
	
	private void WriteStringFieldDefinitionConstructor(IColumn field, string propertyName, string displayName, string isRequired)
	{
		string min = HasMinimumValue(field) ? GetMinimumValue(field).ToString() : "0";
		string max = field.CharacterMaxLength.ToString();
		if (!HasCharacterSet(field))
		{
			%>new TextFieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>, <%= min %>, <%= max %>, TextFieldCharacterSet.Custom)<%
		}
		else
		{
			string charSet = GetCharacterSet(field);
			if (HasCustomCharacterSet(field))
			{
				string customChars = field.Properties["CustomCharacterSet"].Value;
				string exculdeCustomChars = field.Properties.ContainsKey("ExcludeCustomCharacters") ? "true" : "false";
				%>new TextFieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>, <%= min %>, <%= max %>, TextFieldCharacterSet.<%= charSet %>, <%= customChars %>, <%= exculdeCustomChars %>)<%
			}
			else
			{
				%>new TextFieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>, <%= min %>, <%= max %>, TextFieldCharacterSet.<%= charSet %>)<%
			}
		}
	}
	
	private void WriteDataFieldDefinitionConstructor(IColumn field, string propertyName, string displayName, string isRequired)
	{
		string min = HasMinimumValue(field) ? GetMinimumValue(field).ToString() : "null";
		string max = HasMaximumValue(field) ? GetMaximumValue(field).ToString() : "null";
		%>new DataFieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>, <%= min %>, <%= max %>)<%
	}
	
	private void WriteNumericFieldDefinitionConstructor(IColumn field, string propertyName, string displayName, string isRequired)
	{
		string min = HasMinimumValue(field) ? GetMinimumValue(field).ToString() : "null";
		string max = HasMaximumValue(field) ? GetMaximumValue(field).ToString() : "null";
		%>new NumericFieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>, <%= min %>, <%= max %>)<%
	}
	
	private void WriteDateTimeFieldDefinitionConstructor(IColumn field, string propertyName, string displayName, string isRequired)
	{
		string min = HasMinimumValue(field) ? GetMinimumValue(field).ToString() : "null";
		string max = HasMaximumValue(field) ? GetMaximumValue(field).ToString() : "null";
		%>new DateTimeFieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>, <%= min %>, <%= max %>)<%
	}
	
	private void WriteDefaultFieldDefinitionConstructor(IColumn field, string propertyName, string displayName, string isRequired)
	{
		%>new FieldDefinition((int)<%= _fieldIdsType %>.<%= propertyName %>, "<%= displayName %>", <%= isRequired %>)<%
	}
	
	private string ColumnToEncryptedPropertyName(IColumn column)
	{
		return "Encrypted" + ColumnToPropertyName(column);
	}
	
	private string ColumnToEncryptedMemberVariable(IColumn column)
	{
		return "_encrypted" + ToPascalCase(UniqueColumn( column ));
	}
	
	private bool IsEncrypted(IColumn column)
	{
		return column.Properties.ContainsKey("Encrypted");
	}
	
	private bool HasCharacterSet(IColumn column)
	{
		return column.Properties.ContainsKey("CharacterSet");
	}
	
	private bool HasCustomCharacterSet(IColumn column)
	{
		return HasCharacterSet(column) 
			&& GetCharacterSet(column) == "Custom"
			&& column.Properties.ContainsKey("CustomCharacterSet");
	}
	
	private string GetCharacterSet(IColumn column)
	{
		return column.Properties["CharacterSet"].Value;
	}

	private bool HasMinimumValue(IColumn column)
	{
		return column.Properties.ContainsKey("minimumValue");
	}
	
	private string GetMinimumValue(IColumn column)
	{
		return column.Properties["minimumValue"].Value;
	}

	private bool HasMaximumValue(IColumn column)
	{
		return column.Properties.ContainsKey("maximumValue");
	}
	
	private string GetMaximumValue(IColumn column)
	{
		return column.Properties["maximumValue"].Value;
	}

    // Dump all the keys out to the output file. Only use for debugging template
    private void DumpKeys()
    {
		List<IForeignKey> pfks = GetPrimaryForeignKeys();
		List<IForeignKey> npfks = GetNonPrimaryForeignKeys();
		
		%>//Primary FKs:<%
		foreach (IForeignKey fk in pfks)
		{%>
			//<%= fk.Name %><%
		}%>
<% 
		%>//NonPrimary FKs:<%
		foreach (IForeignKey fk in npfks)
		{%>
			//<%= fk.Name %><%
		}%>
<% 
    }
}
%>
##|BODY_END
